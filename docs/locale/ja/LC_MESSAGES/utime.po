# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015-2016, Multiple authors
# This file is distributed under the same license as the BBC micro:bit
# MicroPython package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: BBC micro:bit MicroPython 1.0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-16 17:42+0900\n"
"PO-Revision-Date: 2018-12-16 21:07+0900\n"
"Last-Translator: Minoru Inachi\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../utime.rst:29
msgid "utime"
msgstr ""

#: ../../utime.rst:33
msgid ""
"The ``utime`` module provides functions for getting the current time and "
"date, measuring time intervals, and for delays."
msgstr ""
"``utime`` モジュールには、現在の時間の取得、時間隔を測定、遅延についての関数があります。"

#: ../../utime.rst:37
msgid ""
"The ``utime`` module is a MicroPython implementation of the standard "
"Python ``time`` module. It can be imported using both ``import utime`` "
"and ``import time``, but the module is the same."
msgstr ""
"``utime`` モジュールは、標準の Python の ``time`` モジュールの MicroPython "
"版です。``import utime`` でも ``import time`` でもインポートできますが、"
"モジュールは同じものです。"

#: ../../utime.rst:43
msgid "Functions"
msgstr "関数"

#: ../../utime.rst:47
msgid ""
"Sleep for the given number of seconds. You can use a floating-point "
"number to sleep for a fractional number of seconds, or use the "
":func:`utime.sleep_ms()` and :func:`utime.sleep_us()` functions."
msgstr ""
"指定された秒数の間スリープします。秒より細かい精度で指定したい場合は浮動小数点数"
"を使うか、 :func:`utime.sleep_ms()` や :func:`utime.sleep_us()` 関数を"
"使ってください。"

#: ../../utime.rst:54
msgid "Delay for given number of milliseconds, should be positive or 0."
msgstr "指定のミリ秒間だけ遅延します。ミリ秒の指定は 0 以上の整数である必要があります。"

#: ../../utime.rst:59
msgid "Delay for given number of microseconds, should be positive or 0."
msgstr "指定のマイクロ秒間だけ遅延します。マイクロ秒の指定は 0 以上の整数である必要があります。"

#: ../../utime.rst:64
msgid ""
"Returns an increasing millisecond counter with an arbitrary reference "
"point, that wraps around after some value."
msgstr ""
"呼出し時点での稼働時間をミリ秒単位で返します。稼働時間は最大値に達するとラップ"
"アラウンドします(一周して最低値に戻ります)。"

#: ../../utime.rst:70
msgid "Just like :func:`utime.ticks_ms()` above, but in microseconds."
msgstr "上記の :func:`utime.ticks_ms()` と同じですが、マイクロ秒単位となります。"

#: ../../utime.rst:75
msgid ""
"Offset ticks value by a given number, which can be either positive or "
"negative. Given a ticks value, this function allows to calculate ticks "
"value delta ticks before or after it, following modular-arithmetic "
"definition of tick values."
msgstr ""
"与えた数をティック値からのオフセットとして加算した値を返します。引数の値は正でも負でも"
"かまいません。この関数は、ティック値のモジュール算術定義にしたがい、与えた ticks 値と"
"その前後の delta ティックからティック値を算出します。"

#: ../../utime.rst:80
msgid "Example:"
msgstr "サンプルコード:"

#: ../../utime.rst:82
msgid ""
"# Find out what ticks value there was 100ms ago\n"
"print(ticks_add(time.ticks_ms(), -100))\n"
"\n"
"# Calculate deadline for operation and test for it\n"
"deadline = ticks_add(time.ticks_ms(), 200)\n"
"while ticks_diff(deadline, time.ticks_ms()) > 0:\n"
"    do_a_little_of_something()\n"
"\n"
"# Find out TICKS_MAX used by this port\n"
"print(ticks_add(0, -1))"
msgstr ""
"# 100ms 前のティック値を調べます\n"
"print(ticks_add(time.ticks_ms(), -100))\n"
"\n"
"# 操作やテストのためのデッドラインを算出します\n"
"deadline = ticks_add(time.ticks_ms(), 200)\n"
"while ticks_diff(deadline, time.ticks_ms()) > 0:\n"
"    do_a_little_of_something()\n"
"\n"
"# このポートの TICKS_MAX を調べます\n"
"print(ticks_add(0, -1))"

#: ../../utime.rst:98
msgid ""
"Measure ticks difference between values returned from "
":func:`utime.ticks_ms()` or :func:`ticks_us()` functions, as a signed "
"value which may wrap around."
msgstr ""
":func:`utime.ticks_ms()` や :func:`ticks_us()` 関数の戻り値(ラップアラウンド"
"である可能性のある符号付きの値)の間のティック値の差を計算します。"

#: ../../utime.rst:102
msgid ""
"The argument order is the same as for subtraction operator, "
"``ticks_diff(ticks1, ticks2)`` has the same meaning as ``ticks1 - "
"ticks2``."
msgstr ""
"引数の順序は減算演算子と同じで、 ``ticks_diff(ticks1, ticks2)`` は "
"``ticks1 - ticks2`` と同じ意味を持ちます。"

#: ../../utime.rst:105
msgid ""
":func:`utime.ticks_diff()` is designed to accommodate various usage "
"patterns, among them:"
msgstr ""
":func:`utime.ticks_diff()` は、さまざまな使用パターンに対応するように設計"
"されています:"

#: ../../utime.rst:108
msgid ""
"Polling with timeout. In this case, the order of events is known, and you"
" will deal only with positive results of :func:`utime.ticks_diff()`:"
msgstr ""
"タイムアウトのポーリング - この場合、イベントの順序は既知であり、次のように "
":func:`utime.ticks_diff()` の正の結果のみを処理します:"

#: ../../utime.rst:111
msgid ""
"# Wait for GPIO pin to be asserted, but at most 500us\n"
"start = time.ticks_us()\n"
"while pin.value() == 0:\n"
"    if time.ticks_diff(time.ticks_us(), start) > 500:\n"
"        raise TimeoutError"
msgstr ""
"# GPIOピンから入力があるのを待つが、最大でも50usまで\n"
"start = time.ticks_us()\n"
"while pin.value() == 0:\n"
"    if time.ticks_diff(time.ticks_us(), start) > 500:\n"
"        raise TimeoutError"

#: ../../utime.rst:120
msgid ""
"Scheduling events. In this case, :func:`utime.ticks_diff()` result may be"
" negative if an event is overdue:"
msgstr ""
"イベントのスケジューリング - この場合、イベントが期限切れになると "
":func:`utime.ticks_diff()` の結果が負になります:"

#: ../../utime.rst:124
msgid ""
"# This code snippet is not optimized\n"
"now = time.ticks_ms()\n"
"scheduled_time = task.scheduled_time()\n"
"if ticks_diff(scheduled_time, now) > 0:\n"
"    print(\"Too early, let's nap\")\n"
"    sleep_ms(ticks_diff(scheduled_time, now))\n"
"    task.run()\n"
"elif ticks_diff(scheduled_time, now) == 0:\n"
"    print(\"Right at time!\")\n"
"    task.run()\n"
"elif ticks_diff(scheduled_time, now) < 0:\n"
"    print(\"Oops, running late, tell task to run faster!\")\n"
"    task.run(run_faster=true)"
msgstr ""
"# このコードは最適化されていません\n"
"now = time.ticks_ms()\n"
"scheduled_time = task.scheduled_time()\n"
"if ticks_diff(scheduled_time, now) > 0:\n"
"    print(\"Too early, let's nap\")\n"
"    sleep_ms(ticks_diff(scheduled_time, now))\n"
"    task.run()\n"
"elif ticks_diff(scheduled_time, now) == 0:\n"
"    print(\"Right at time!\")\n"
"    task.run()\n"
"elif ticks_diff(scheduled_time, now) < 0:\n"
"    print(\"Oops, running late, tell task to run faster!\")\n"
"    task.run(run_faster=true)"

