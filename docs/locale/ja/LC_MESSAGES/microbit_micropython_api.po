# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015-2016, Multiple authors
# This file is distributed under the same license as the BBC micro:bit
# MicroPython package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: BBC micro:bit MicroPython 0.0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-10-09 10:10+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../../microbit_micropython_api.rst:2
msgid "micro:bit Micropython API"
msgstr ""

#: ../../microbit_micropython_api.rst:5
msgid ""
"As we work towards a 1.0 release, this API is subject to frequent "
"changes. This page reflects the current micro:bit API in a developer-"
"friendly (but not necessarily kid-friendly) way. The tutorials associated"
" with this documentation are a good place to start for non-developers "
"looking for information."
msgstr ""
"1.0 リリースに向けて作業中のため、このAPIは頻繁に変更される可能性があります。"
"このページは、現時点での micro:bit API を反映していて、開発者向けのものです"
"(必ずしも子供に優しいわけではありません)。開発者以外の人が情報を探すのには、"
"このドキュメンテーションに関連しているチュートリアルが適しています。"

#: ../../microbit_micropython_api.rst:8
msgid "The microbit module"
msgstr "microbit モジュール"

#: ../../microbit_micropython_api.rst:10
msgid ""
"Everything directly related to interacting with the hardware lives in the"
" `microbit` module.  For ease of use it's recommended you start all "
"scripts with::"
msgstr ""
"ハードウェアと相互に直接関係するものはすべて `microbit` モジュールにあります。"
"使いやすさを考慮して、すべてのスクリプトは次の方法で起動することをお勧めします::"

#: ../../microbit_micropython_api.rst:12
msgid "from microbit import *"
msgstr ""

#: ../../microbit_micropython_api.rst:14
msgid "The following documentation assumes you have done this."
msgstr "以下のドキュメントは、これを行ったことを前提としています。"

#: ../../microbit_micropython_api.rst:16
msgid "There are a few functions available directly::"
msgstr "いくつかの機能が直接利用可能です::"

#: ../../microbit_micropython_api.rst:18
msgid ""
"# sleep for the given number of milliseconds.\n"
"sleep(ms)\n"
"# returns the number of milliseconds since the micro:bit was last "
"switched on.\n"
"running_time()\n"
"# makes the micro:bit enter panic mode (this usually happens when the DAL"
" runs\n"
"# out of memory, and causes a sad face to be drawn on the display). The "
"error\n"
"# code can be any arbitrary integer value.\n"
"panic(error_code)\n"
"# resets the micro:bit.\n"
"reset()"
msgstr ""
"# 指定したミリ秒数だけ休止します。\n"
"sleep(ms)\n"
"# micro:bit の電源が入ってから経過したミリ秒数を返します。\n"
"running_time()\n"
"# micro:bit をパニックモードにします(これは通常、デバイス抽象レイヤーがメモリ不足になったときに\n"
"# 起き、ディスプレイに悲しい顔が出ます)。エラーコードには任意の整数値を指定できます。\n"
"panic(error_code)\n"
"# micro:bit をリセットします。\n"
"reset()"

#: ../../microbit_micropython_api.rst:29
msgid ""
"The rest of the functionality is provided by objects and classes in the "
"microbit module, as described below."
msgstr ""
"残りの機能は、後述するように microbit モジュール内のオブジェクトおよびクラスによって"
"提供されます。"

#: ../../microbit_micropython_api.rst:31
msgid ""
"Note that the API exposes integers only (ie no floats are needed, but "
"they may be accepted).  We thus use milliseconds for the standard time "
"unit."
msgstr ""
"は数値として整数だけを利用しています(つまり、浮動小数点数は必要ないということですが、"
"受け付けるものもあります)。したがって標準の時間単位にはミリ秒を使用します。"

#: ../../microbit_micropython_api.rst:34
msgid "Buttons"
msgstr "ボタン"

#: ../../microbit_micropython_api.rst:36
msgid "There are 2 buttons::"
msgstr "２つのボタンがあります::"

#: ../../microbit_micropython_api.rst:38
msgid ""
"button_a\n"
"button_b"
msgstr ""

#: ../../microbit_micropython_api.rst:41
msgid "These are both objects and have the following methods::"
msgstr "これらはどちらもオブジェクトであり、次のメソッドがあります::"

#: ../../microbit_micropython_api.rst:43
msgid ""
"# returns True or False to indicate if the button is pressed at the time "
"of\n"
"# the method call.\n"
"button.is_pressed()\n"
"# returns True or False to indicate if the button was pressed since the "
"device\n"
"# started or the last time this method was called.\n"
"button.was_pressed()\n"
"# returns the running total of button presses, and resets this counter to"
" zero\n"
"button.get_presses()"
msgstr ""
"# メソッドを呼んだときにボタンが押されているかにより True または False \n"
"# を返します。\n"
"button.is_pressed()\n"
"# デバイスが始動まやは前回にこのメソッドが呼び出されてからボタンが\n"
"# 押されたかにより True または False を返します。\n"
"button.was_pressed()\n"
"# ボタン押下の回数を返し、このカウンタをゼロにリセットします。\n"
"button.get_presses()"

#: ../../microbit_micropython_api.rst:53
msgid "The LED display"
msgstr "LED ディスプレイ"

#: ../../microbit_micropython_api.rst:55
msgid "The LED display is exposed via the `display` object::"
msgstr "LED ディスプレイは `display` オブジェクトを介して利用します::"

#: ../../microbit_micropython_api.rst:57
msgid ""
"# gets the brightness of the pixel (x,y). Brightness can be from 0 (the "
"pixel\n"
"# is off) to 9 (the pixel is at maximum brightness).\n"
"display.get_pixel(x, y)\n"
"# sets the brightness of the pixel (x,y) to val (between 0 [off] and 9 "
"[max\n"
"# brightness], inclusive).\n"
"display.set_pixel(x, y, val)\n"
"# clears the display.\n"
"display.clear()\n"
"# shows the image.\n"
"display.show(image, delay=0, wait=True, loop=False, clear=False)\n"
"# shows each image or letter in the iterable, with delay ms. in between "
"each.\n"
"display.show(iterable, delay=400, wait=True, loop=False, clear=False)\n"
"# scrolls a string across the display (more exciting than display.show "
"for\n"
"# written messages).\n"
"display.scroll(string, delay=400)"
msgstr ""
"# ピクセル (x, y)の照度を得ます。照度は 0 (ピクセルがオフ)から 9 (ピクセルが最大照度)\n"
"# までの値をとります。\n"
"display.get_pixel(x, y)\n"
"# ピクセル (x, y)の照度に val (0 [オフ] から 9 [最大照度] の範囲)\n"
"# を設定します。\n"
"display.set_pixel(x, y, val)\n"
"# ディスプレィをクリアします。\n"
"display.clear()\n"
"# イメージを表示します。\n"
"display.show(image, delay=0, wait=True, loop=False, clear=False)\n"
"# iterable のイメージまたは文字のそれぞれを delay ミリ秒間隔で表示する。\n"
"display.show(iterable, delay=400, wait=True, loop=False, clear=False)\n"
"# 文字列 string をディスプレイでスクロールします(メッセージを表示するなら display.show \n"
"# よりも効果的)。\n"
"display.scroll(string, delay=400)"

#: ../../microbit_micropython_api.rst:74
msgid "Pins"
msgstr "端子"

#: ../../microbit_micropython_api.rst:76
msgid ""
"Provide digital and analog input and output functionality, for the pins "
"in the connector. Some pins are connected internally to the I/O that "
"drives the LED matrix and the buttons."
msgstr ""
"コネクタの端子に、デジタルおよびアナログの入出力機能を提供します。一部の端子は LED "
"マトリクスとボタンを駆動する I/O に内部接続されています。"

#: ../../microbit_micropython_api.rst:78
msgid ""
"Each pin is provided as an object directly in the ``microbit`` module.  "
"This keeps the API relatively flat, making it very easy to use:"
msgstr ""
"各端子は ``microbit`` モジュールで直接オブジェクトとして提供されます。これにより API "
"が比較的フラットに保たれ、利用が非常に簡単になります。"

#: ../../microbit_micropython_api.rst:80
msgid "pin0"
msgstr ""

#: ../../microbit_micropython_api.rst:81
msgid "pin1"
msgstr ""

#: ../../microbit_micropython_api.rst:82
msgid "..."
msgstr ""

#: ../../microbit_micropython_api.rst:83
msgid "pin15"
msgstr ""

#: ../../microbit_micropython_api.rst:84
msgid "pin16"
msgstr ""

#: ../../microbit_micropython_api.rst:85
msgid "*Warning: P17-P18 (inclusive) are unavailable.*"
msgstr "*注意: P17-P18 は利用できません。*"

#: ../../microbit_micropython_api.rst:86
msgid "pin19"
msgstr ""

#: ../../microbit_micropython_api.rst:87
msgid "pin20"
msgstr ""

#: ../../microbit_micropython_api.rst:89
msgid ""
"Each of these pins are instances of the ``MicroBitPin`` class, which "
"offers the following API::"
msgstr ""
"これらの端子はそれぞれ ``MicroBitPin`` クラスのインスタンスであり、次のAPIを"
"提供します。"

#: ../../microbit_micropython_api.rst:91
msgid ""
"# value can be 0, 1, False, True\n"
"pin.write_digital(value)\n"
"# returns either 1 or 0\n"
"pin.read_digital()\n"
"# value is between 0 and 1023\n"
"pin.write_analog(value)\n"
"# returns an integer between 0 and 1023\n"
"pin.read_analog()\n"
"# sets the period of the PWM output of the pin in milliseconds\n"
"# (see https://en.wikipedia.org/wiki/Pulse-width_modulation)\n"
"pin.set_analog_period(int)\n"
"# sets the period of the PWM output of the pin in microseconds\n"
"# (see https://en.wikipedia.org/wiki/Pulse-width_modulation)\n"
"pin.set_analog_period_microseconds(int)\n"
"# returns boolean\n"
"pin.is_touched()"
msgstr ""
"# 値 value を 0, 1, False, True のいずれかにできます。\n"
"pin.write_digital(value)\n"
"# 1 か 0 を返します。\n"
"pin.read_digital()\n"
"# value は 0 から 1023 の範囲の値です。\n"
"pin.write_analog(value)\n"
"# 0 から 1023 の範囲の整数値を返します。\n"
"pin.read_analog()\n"
"# 端子の PWM 出力周期をミリ秒単位で設定します。\n"
"# (https://ja.wikipedia.org/wiki/パルス幅変調 を参照)\n"
"pin.set_analog_period(int)\n"
"# 端子の PWM 出力周期をマイクロ秒単位で設定します。\n"
"# (https://ja.wikipedia.org/wiki/パルス幅変調 を参照)\n"
"pin.set_analog_period_microseconds(int)\n"
"# 端子に触れているかをブール値で返します。\n"
"pin.is_touched()"

#: ../../microbit_micropython_api.rst:109
msgid "Images"
msgstr "イメージ"

#: ../../microbit_micropython_api.rst:113
msgid ""
"You don't always need to create one of these yourself - you can access "
"the image shown on the display directly with `display.image`. "
"`display.image` is just an instance of `Image`, so you can use all of the"
" same methods."
msgstr ""
"いつも自分でイメージを作成する必要はありません。 ``display.image`` "
"を使用してディスプレイに表示されるイメージに直接アクセスできます。 "
"``display.image`` は Image の単なるインスタンスなので、同じメソッドをすべて"
"使用できます。"

#: ../../microbit_micropython_api.rst:117
msgid "Images API::"
msgstr "イメージ API"

#: ../../microbit_micropython_api.rst:119
msgid ""
"# creates an empty 5x5 image\n"
"image = Image()\n"
"# create an image from a string - each character in the string represents"
" an\n"
"# LED - 0 (or space) is off and 9 is maximum brightness. The colon \":\"\n"
"# indicates the end of a line.\n"
"image = Image('90009:09090:00900:09090:90009:')\n"
"# create an empty image of given size\n"
"image = Image(width, height)\n"
"# initialises an Image with the specified width and height. The buffer\n"
"# should be an array of length width * height\n"
"image = Image(width, height, buffer)\n"
"\n"
"# methods\n"
"# returns the image's width (most often 5)\n"
"image.width()\n"
"# returns the image's height (most often 5)\n"
"image.height()\n"
"# sets the pixel at the specified position (between 0 and 9). May fail "
"for\n"
"# constant images.\n"
"image.set_pixel(x, y, value)\n"
"# gets the pixel at the specified position (between 0 and 9)\n"
"image.get_pixel(x, y)\n"
"# returns a new image created by shifting the picture left 'n' times.\n"
"image.shift_left(n)\n"
"# returns a new image created by shifting the picture right 'n' times.\n"
"image.shift_right(n)\n"
"# returns a new image created by shifting the picture up 'n' times.\n"
"image.shift_up(n)\n"
"# returns a new image created by shifting the picture down 'n' times.\n"
"image.shift_down(n)\n"
"# get a compact string representation of the image\n"
"repr(image)\n"
"# get a more readable string representation of the image\n"
"str(image)\n"
"\n"
"#operators\n"
"# returns a new image created by superimposing the two images\n"
"image + image\n"
"# returns a new image created by multiplying the brightness of each pixel"
" by n\n"
"image * n\n"
"\n"
"# built-in images.\n"
"Image.HEART\n"
"Image.HEART_SMALL\n"
"Image.HAPPY\n"
"Image.SMILE\n"
"Image.SAD\n"
"Image.CONFUSED\n"
"Image.ANGRY\n"
"Image.ASLEEP\n"
"Image.SURPRISED\n"
"Image.SILLY\n"
"Image.FABULOUS\n"
"Image.MEH\n"
"Image.YES\n"
"Image.NO\n"
"Image.CLOCK12 # clock at 12 o' clock\n"
"Image.CLOCK11\n"
"... # many clocks (Image.CLOCKn)\n"
"Image.CLOCK1 # clock at 1 o'clock\n"
"Image.ARROW_N\n"
"... # arrows pointing N, NE, E, SE, S, SW, W, NW "
"(microbit.Image.ARROW_direction)\n"
"Image.ARROW_NW\n"
"Image.TRIANGLE\n"
"Image.TRIANGLE_LEFT\n"
"Image.CHESSBOARD\n"
"Image.DIAMOND\n"
"Image.DIAMOND_SMALL\n"
"Image.SQUARE\n"
"Image.SQUARE_SMALL\n"
"Image.RABBIT\n"
"Image.COW\n"
"Image.MUSIC_CROTCHET\n"
"Image.MUSIC_QUAVER\n"
"Image.MUSIC_QUAVERS\n"
"Image.PITCHFORK\n"
"Image.XMAS\n"
"Image.PACMAN\n"
"Image.TARGET\n"
"Image.TSHIRT\n"
"Image.ROLLERSKATE\n"
"Image.DUCK\n"
"Image.HOUSE\n"
"Image.TORTOISE\n"
"Image.BUTTERFLY\n"
"Image.STICKFIGURE\n"
"Image.GHOST\n"
"Image.SWORD\n"
"Image.GIRAFFE\n"
"Image.SKULL\n"
"Image.UMBRELLA\n"
"Image.SNAKE\n"
"# built-in lists - useful for animations, e.g. "
"display.show(Image.ALL_CLOCKS)\n"
"Image.ALL_CLOCKS\n"
"Image.ALL_ARROWS"
msgstr ""
"# 空の 5x5 イメージを作成。\n"
"image = Image()\n"
"# 文字列からイメージを作成 - 文字列中の各文字は LED を表す - 0 (またはスペース)はオフ、\n"
"# \"9 は最大照度。コロン \":\" は行の終端を示します。\n"
"image = Image('90009:09090:00900:09090:90009:')\n"
"# 与えたサイズの空のイメージを作成します。\n"
"image = Image(width, height)\n"
"# 指定の width と height でイメージを初期化します。buffer は長さが \n"
"# width * height の配列です。\n"
"image = Image(width, height, buffer)\n"
"\n"
"# メソッド\n"
"# イメージの width (最大 5)を返します。\n"
"image.width()\n"
"# イメージの height (最大 5)を返します。\n"
"image.height()\n"
"# 指定の位置のピクセルを設定します(0 から 9 の範囲)。組込みのイメージでは\n"
"# 失敗します。\n"
"image.set_pixel(x, y, value)\n"
"# 指定の位置のピクセルを得ます(0 から 9 の範囲)。\n"
"image.get_pixel(x, y)\n"
"# イメージを左に 'n' 回シフトした新しいイメージを返します。\n"
"image.shift_left(n)\n"
"# イメージを右に 'n' 回シフトした新しいイメージを返します。\n"
"image.shift_right(n)\n"
"# イメージを上に 'n' 回シフトした新しいイメージを返します。\n"
"image.shift_up(n)\n"
"# イメージを下に 'n' 回シフトした新しいイメージを返します。\n"
"image.shift_down(n)\n"
"# イメージのコンパクトな文字列表現を得ます。\n"
"repr(image)\n"
"# イメージのより可読性のある文字列表現を得ます。\n"
"str(image)\n"
"\n"
"#演算子\n"
"# ２つのイメージを重ね合わせた新しいイメージを返します。\n"
"image + image\n"
"# 各ピクセルの照度に n を掛けた新しいイメージを返します。\n"
"image * n\n"
"\n"
"# 組込みのイメージ。\n"
"Image.HEART\n"
"Image.HEART_SMALL\n"
"Image.HAPPY\n"
"Image.SMILE\n"
"Image.SAD\n"
"Image.CONFUSED\n"
"Image.ANGRY\n"
"Image.ASLEEP\n"
"Image.SURPRISED\n"
"Image.SILLY\n"
"Image.FABULOUS\n"
"Image.MEH\n"
"Image.YES\n"
"Image.NO\n"
"Image.CLOCK12 # 12 時を示す時計\n"
"Image.CLOCK11\n"
"... # 多くの時計イメージ (Image.CLOCKn)\n"
"Image.CLOCK1 # clock at 1 o'clock\n"
"Image.ARROW_N\n"
"... # 方角を示す矢印 N, NE, E, SE, "
"S, SW, W, NW (microbit.Image.ARROW_direction)"
"\n"
"Image.ARROW_NW\n"
"Image.TRIANGLE\n"
"Image.TRIANGLE_LEFT\n"
"Image.CHESSBOARD\n"
"Image.DIAMOND\n"
"Image.DIAMOND_SMALL\n"
"Image.SQUARE\n"
"Image.SQUARE_SMALL\n"
"Image.RABBIT\n"
"Image.COW\n"
"Image.MUSIC_CROTCHET\n"
"Image.MUSIC_QUAVER\n"
"Image.MUSIC_QUAVERS\n"
"Image.PITCHFORK\n"
"Image.XMAS\n"
"Image.PACMAN\n"
"Image.TARGET\n"
"Image.TSHIRT\n"
"Image.ROLLERSKATE\n"
"Image.DUCK\n"
"Image.HOUSE\n"
"Image.TORTOISE\n"
"Image.BUTTERFLY\n"
"Image.STICKFIGURE\n"
"Image.GHOST\n"
"Image.SWORD\n"
"Image.GIRAFFE\n"
"Image.SKULL\n"
"Image.UMBRELLA\n"
"Image.SNAKE\n"
"# 組込みのリスト - アニメーションに便利。例： display.show(Image.ALL_CLOCKS)\n"
"Image.ALL_CLOCKS\n"
"Image.ALL_ARROWS"

#: ../../microbit_micropython_api.rst:216
msgid "The accelerometer"
msgstr "加速度センサー"

#: ../../microbit_micropython_api.rst:218
msgid "The accelerometer is accessed via the ``accelerometer`` object::"
msgstr "加速度センサーは ``accelerometer`` オブジェクトを介して利用します::"

#: ../../microbit_micropython_api.rst:220
msgid ""
"# read the X axis of the device. Measured in milli-g.\n"
"accelerometer.get_x()\n"
"# read the Y axis of the device. Measured in milli-g.\n"
"accelerometer.get_y()\n"
"# read the Z axis of the device. Measured in milli-g.\n"
"accelerometer.get_z()\n"
"# get tuple of all three X, Y and Z readings (listed in that order).\n"
"accelerometer.get_values()\n"
"# return the name of the current gesture.\n"
"accelerometer.current_gesture()\n"
"# return True or False to indicate if the named gesture is currently "
"active.\n"
"accelerometer.is_gesture(name)\n"
"# return True or False to indicate if the named gesture was active since "
"the\n"
"# last call.\n"
"accelerometer.was_gesture(name)\n"
"# return a tuple of the gesture history. The most recent is listed last.\n"
"accelerometer.get_gestures()"
msgstr ""
"# デバイスの X 軸を読みます。ミリg単位で計測します。\n"
"accelerometer.get_x()\n"
"# デバイスの Y 軸を読みます。ミリg単位で計測します。\n"
"accelerometer.get_y()\n"
"# デバイスの Z 軸を読みます。ミリg単位で計測します。\n"
"accelerometer.get_z()\n"
"# X, Y, Z の３軸すべてを(この順番の並びで)得ます。\n"
"accelerometer.get_values()\n"
"# 現在のジェスチャの名前を返します。\n"
"accelerometer.current_gesture()\n"
"# 指定の名前のジェスチャが現在行われているかにより True または False を返します。\n"
"accelerometer.is_gesture(name)\n"
"# 最後に呼び出されてから、指定の名前のジェスチャが行われたかにより True または False を\n"
"# 返します。\n"
"accelerometer.was_gesture(name)\n"
"# ジェスチャの履歴のタプルを返します。直近のものが最後に並びます。\n"
"accelerometer.get_gestures()"

#: ../../microbit_micropython_api.rst:238
msgid ""
"The recognised gestures are: ``up``, ``down``, ``left``, ``right``, "
"``face up``, ``face down``, ``freefall``, ``3g``, ``6g``, ``8g``, "
"``shake``."
msgstr ""
"認識ジェスチャーは以下のとおりです: ``up``, ``down``, ``left``, ``right``, ``face up``, "
"``face down``, ``freefall``, ``3g``, ``6g``, ``8g``, ``shake`` 。"

#: ../../microbit_micropython_api.rst:242
msgid "The compass"
msgstr "コンパス"

#: ../../microbit_micropython_api.rst:244
msgid "The compass is accessed via the `compass` object::"
msgstr "コンパスは `compass` コンパスオブジェクトを介して利用します::"

#: ../../microbit_micropython_api.rst:246
msgid ""
"# calibrate the compass (this is needed to get accurate readings).\n"
"compass.calibrate()\n"
"# return a numeric indication of degrees offset from \"north\".\n"
"compass.heading()\n"
"# return an numeric indication of the strength of magnetic field around\n"
"# the micro:bit.\n"
"compass.get_field_strength()\n"
"# returns True or False to indicate if the compass is calibrated.\n"
"compass.is_calibrated()\n"
"# resets the compass to a pre-calibration state.\n"
"compass.clear_calibration()"
msgstr ""
"# コンパスを調整します(これは正確な計測のために必要です)。\n"
"compass.calibrate()\n"
"# \"北\" からの相対角度を示す数値を返します。\n"
"compass.heading()\n"
"# micro:bit の周りの磁場の強度を示す数値を返します。\n"
"compass.get_field_strength()\n"
"# コンパスが調整されているかにより True または False を返します。\n"
"compass.is_calibrated()\n"
"# コンパスの調整されていた状態をリセットします。\n"
"compass.clear_calibration()"

#: ../../microbit_micropython_api.rst:259
msgid "I2C bus"
msgstr "I2C バス"

#: ../../microbit_micropython_api.rst:261
msgid ""
"There is an I2C bus on the micro:bit that is exposed via the `i2c` "
"object.  It has the following methods::"
msgstr ""
"micro:bit には I2C バスがあり、 `i2c` オブジェクトを介して利用します。"
"このオブジェクトには以下のメソッドがあります::"

#: ../../microbit_micropython_api.rst:263
msgid ""
"# read n bytes from device with addr; repeat=True means a stop bit won't\n"
"# be sent.\n"
"i2c.read(addr, n, repeat=False)\n"
"# write buf to device with addr; repeat=True means a stop bit won't be "
"sent.\n"
"i2c.write(addr, buf, repeat=False)"
msgstr ""
"# アドレス addr のデバイスから n バイト読み込みます。repeat=True はストップビットが\n"
"# 送信されないことを意味します。\n"
"i2c.read(addr, n, repeat=False)\n"
"# アドレス addr のデバイスに buf を書き出します。repeat=True はストップビットが\n"
"# 送信されないことを意味します。\n"
"i2c.write(addr, buf, repeat=False)"

#: ../../microbit_micropython_api.rst:270
msgid "UART"
msgstr ""

#: ../../microbit_micropython_api.rst:272
msgid ""
"Use ``uart`` to communicate with a serial device connected to the "
"device's I/O pins::"
msgstr ""
"I/O 端子に接続されたシリアルデバイスとの通信には ``uart`` "
"を使います::"

#: ../../microbit_micropython_api.rst:274
msgid ""
"# set up communication (use pins 0 [TX] and 1 [RX]) with a baud rate of "
"9600.\n"
"uart.init()\n"
"# return True or False to indicate if there are incoming characters "
"waiting to\n"
"# be read.\n"
"uart.any()\n"
"# return (read) n incoming characters.\n"
"uart.read(n)\n"
"# return (read) as much incoming data as possible.\n"
"uart.readall()\n"
"# return (read) all the characters to a newline character is reached.\n"
"uart.readline()\n"
"# read bytes into the referenced buffer.\n"
"uart.readinto(buffer)\n"
"# write bytes from the buffer to the connected device.\n"
"uart.write(buffer)"
msgstr ""
"# ボーレート 9600 で(端子 0 [TX] と 1 [RX] を使う)通信をセットアップします。\n"
"uart.init()\n"
"# 読込みを待っている文字を受信しているかにより True または False を\n"
"# 返します。\n"
"uart.any()\n"
"# 受信している文字を n だけ読んで返します。\n"
"uart.read(n)\n"
"# 受信している文字を可能なだけ(読んで)返します。\n"
"uart.readall()\n"
"# 改行文字に達するまでのすべての文字を(読んで)返します。\n"
"uart.readline()\n"
"# 指定のバッファにバイト列を読み込みます。\n"
"uart.readinto(buffer)\n"
"# 接続したデバイスにバッファのバイト列を書き出します。\n"
"uart.write(buffer)"

