# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015-2016, Multiple authors
# This file is distributed under the same license as the BBC micro:bit
# MicroPython package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: BBC micro:bit MicroPython 0.5.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-28 11:29+0900\n"
"PO-Revision-Date: 2021-11-28 11:32+0900\n"
"Last-Translator: Minoru Inachi\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../../accelerometer.rst:2
msgid "Accelerometer"
msgstr "加速度センサー"

#: ../../accelerometer.rst:6
msgid ""
"This object gives you access to the on-board accelerometer. The "
"accelerometer also provides convenience functions for detecting gestures."
" The recognised gestures are: ``up``, ``down``, ``left``, ``right``, "
"``face up``, ``face down``, ``freefall``, ``3g``, ``6g``, ``8g``, "
"``shake``."
msgstr ""
"このオブジェクトでボード上の加速度センサーにアクセスできます。加速度センサーは"
"ジェスチャーを検出するのにも使えます。認識できるジェスチャーとしては "
"``up``, ``down``, ``left``, ``right``, ``face up``, ``face down``, "
"``freefall``, ``3g``, ``6g``, ``8g``, ``shake`` があります。"

#: ../../accelerometer.rst:11
msgid ""
"By default MicroPython sets the accelerometer range to +/- 2g, changing "
"the accelerometer range is currently not possible in MicroPython. The "
"accelerometer returns a value in the range 0..1024 for each axis, which "
"is then scaled accordingly."
msgstr ""
"デフォルトで MicroPython は加速度センサーの測定範囲を +/- 2g に設定しますが、"
"現在のところ MicroPython で加速度センサーの測定範囲は変更できません。"
"加速度センサーは、各軸について加速度に応じてスケーリングされた 0..1024 の範囲の"
"値を返しします。"

#: ../../accelerometer.rst:17
msgid "Functions"
msgstr "関数"

#: ../../accelerometer.rst:21
msgid ""
"Get the acceleration measurement in the ``x`` axis, as a positive or "
"negative integer, depending on the direction. The measurement is given in"
" milli-g. By default the accelerometer is configured with a range of +/- "
"2g, and so this method will return within the range of +/- 2000mg."
msgstr ""
"``x`` 軸の加速度を得ます。方向に応じて正または負の整数値になります。"
"測定はミリg単位で行われます。"デフォルトで加速度センサーの測定範囲は +/- 2g に"
"設定されているため、このメソッドは +/- 2000mg の範囲内で返します。"

#: ../../accelerometer.rst:28
msgid ""
"Get the acceleration measurement in the ``y`` axis, as a positive or "
"negative integer, depending on the direction. The measurement is given in"
" milli-g. By default the accelerometer is configured with a range of +/- "
"2g, and so this method will return within the range of +/- 2000mg."
msgstr ""
"``y`` 軸の加速度を得ます。方向に応じて正または負の整数値になります。"
"測定はミリg単位で行われます。"デフォルトで加速度センサーの測定範囲は +/- 2g に"
"設定されているため、このメソッドは +/- 2000mg の範囲内で返します。"

#: ../../accelerometer.rst:35
msgid ""
"Get the acceleration measurement in the ``z`` axis, as a positive or "
"negative integer, depending on the direction. The measurement is given in"
" milli-g. By default the accelerometer is configured with a range of +/- "
"2g, and so this method will return within the range of +/- 2000mg."
msgstr ""
"``z`` 軸の加速度を得ます。方向に応じて正または負の整数値になります。"
"測定はミリg単位で行われます。"デフォルトで加速度センサーの測定範囲は +/- 2g に"
"設定されているため、このメソッドは +/- 2000mg の範囲内で返します。"

#: ../../accelerometer.rst:42
msgid ""
"Get the acceleration measurements in all axes at once, as a three-element"
" tuple of integers ordered as X, Y, Z. By default the accelerometer is "
"configured with a range of +/- 2g, and so X, Y, and Z will be within the "
"range of +/-2000mg."
msgstr ""
"すべての軸の加速度を得ます。X, Y, Z の順番の３要素の整数値のタプルが返ります。"
"測定はミリg単位で行われます。"デフォルトで加速度センサーの測定範囲は +/- 2g に"
"設定されているため、X, Y, Z は +/- 2000mg の範囲内になります。"

#: ../../accelerometer.rst:49
msgid ""
"Get the acceleration measurement of all axes combined, as a positive "
"integer.  This is the Pythagorean sum of the X, Y and Z axes, with the "
"measurement given in milli-g."
msgstr ""
"すべての軸を組み合わせた加速度の測定値を正の整数で取得します。"
"これは、X、Y、Z軸のピタゴラス和で、測定値はミリg単位で与えられます。"

#: ../../accelerometer.rst:55
msgid "Return the name of the current gesture."
msgstr "現在のジェスチャーの名前を返します。"

#: ../../accelerometer.rst:59
msgid ""
"MicroPython understands the following gesture names: ``\"up\"``, "
"``\"down\"``, ``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face "
"down\"``, ``\"freefall\"``, ``\"3g\"``, ``\"6g\"``, ``\"8g\"``, "
"``\"shake\"``. Gestures are always represented as strings."
msgstr ""
"MicroPython は次の名前のジェスチャーを認識します: ``\"up\"``, ``\"down\"``, ``\"left\"``, "
"``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``, "
"``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"`` 。ジェスチャーは常に文字列で表されます。"

#: ../../accelerometer.rst:66
msgid "Return True or False to indicate if the named gesture is currently active."
msgstr "指定した名前のジェスチャーが認識されているかにより True または False を返します。"

#: ../../accelerometer.rst:70
msgid ""
"Return True or False to indicate if the named gesture was active since "
"the last call."
msgstr ""
"前回の呼出し以降に指定した名前のジェスチャーが認識されたかにより True "
"または False を返します。"

#: ../../accelerometer.rst:75
msgid ""
"Return a tuple of the gesture history. The most recent is listed last. "
"Also clears the gesture history before returning."
msgstr ""
"ジェスチャーの履歴をタプルで返します。タプルは古い順に並び、最新のものが最後の要素に"
"なります。この呼出しを行うとジェスチャーの履歴はクリアされます。"

#: ../../accelerometer.rst:80
msgid ""
"Gestures are not updated in the background so there needs to be constant "
"calls to some accelerometer method to do the gesture detection. Usually "
"gestures can be detected using a loop with a small :func:`microbit.sleep` delay."
msgstr ""
"ジェスチャーはバックグラウンドでは更新されないため、ジェスチャー検出を行うには、"
"何らかの加速度センサーのメソッドを常に呼び出す必要があります。通常、ジェスチャーは "
":func:`microbit.sleep` による小さな遅延のあるループを使って検出できます。"

#: ../../accelerometer.rst:86
msgid ""
"Set the accelerometer sensitivity range, in g (standard gravity), to the "
"closest values supported by the hardware, so it rounds to either ``1``, "
"``2``, ``4``, or ``8`` g."
msgstr ""
"加速度センサーの感度の範囲を g (標準重力)で設定し、ハードウェアがサポートする最も近い値、"
"つまり ``1``, ``2``, ``4``, or ``8`` g のいずれかに丸めます。"

#: ../../accelerometer.rst:91
msgid "Examples"
msgstr "サンプルコード"

#: ../../accelerometer.rst:93
msgid ""
"A fortune telling magic 8-ball. Ask a question then shake the device for "
"an answer."
msgstr ""
"マジック８ボール占いです。質問の後にデバイスをゆさぶってください。"

#: ../../accelerometer.rst:84
msgid ""
"# Magic 8 ball by Nicholas Tollervey. February 2016.\n"
"#\n"
"# Ask a question then shake.\n"
"#\n"
"# This program has been placed into the public domain.\n"
"from microbit import *\n"
"import random\n"
"\n"
"answers = [\n"
"    \"It is certain\",\n"
"    \"It is decidedly so\",\n"
"    \"Without a doubt\",\n"
"    \"Yes, definitely\",\n"
"    \"You may rely on it\",\n"
"    \"As I see it, yes\",\n"
"    \"Most likely\",\n"
"    \"Outlook good\",\n"
"    \"Yes\",\n"
"    \"Signs point to yes\",\n"
"    \"Reply hazy try again\",\n"
"    \"Ask again later\",\n"
"    \"Better not tell you now\",\n"
"    \"Cannot predict now\",\n"
"    \"Concentrate and ask again\",\n"
"    \"Don't count on it\",\n"
"    \"My reply is no\",\n"
"    \"My sources say no\",\n"
"    \"Outlook not so good\",\n"
"    \"Very doubtful\",\n"
"]\n"
"\n"
"while True:\n"
"    display.show('8')\n"
"    if accelerometer.was_gesture('shake'):\n"
"        display.clear()\n"
"        sleep(1000)\n"
"        display.scroll(random.choice(answers))\n"
"    sleep(10)"
msgstr ""
"# マジック８ボール占い　作成者：Nicholas Tollervey　2016年2月。\n"
"#\n"
"# 質問の後にデバイスを振ってゆさぶってください。\n"
"#\n"
"# このプログラムはパブリックドメインで公開します。\n"
"from microbit import *\n"
"import random\n"
"\n"
"answers = [\n"
"    \"It is certain\",\n"
"    \"It is decidedly so\",\n"
"    \"Without a doubt\",\n"
"    \"Yes, definitely\",\n"
"    \"You may rely on it\",\n"
"    \"As I see it, yes\",\n"
"    \"Most likely\",\n"
"    \"Outlook good\",\n"
"    \"Yes\",\n"
"    \"Signs point to yes\",\n"
"    \"Reply hazy try again\",\n"
"    \"Ask again later\",\n"
"    \"Better not tell you now\",\n"
"    \"Cannot predict now\",\n"
"    \"Concentrate and ask again\",\n"
"    \"Don't count on it\",\n"
"    \"My reply is no\",\n"
"    \"My sources say no\",\n"
"    \"Outlook not so good\",\n"
"    \"Very doubtful\",\n"
"]\n"
"\n"
"while True:\n"
"    display.show('8')\n"
"    if accelerometer.was_gesture('shake'):\n"
"        display.clear()\n"
"        sleep(1000)\n"
"        display.scroll(random.choice(answers))\n"
"    sleep(10)"

#: ../../accelerometer.rst:99
msgid "Simple Slalom. Move the device to avoid the obstacles."
msgstr "単純なスラロームです。デバイスを動かして障害物を避けてください。"

msgid ""
"# Simple Slalom by Larry Hastings, September 2015\n"
"#\n"
"# This program has been placed into the public domain.\n"
"\n"
"import microbit as m\n"
"import random\n"
"\n"
"p = m.display.show\n"
"\n"
"min_x = -1024\n"
"max_x = 1024\n"
"range_x = max_x - min_x\n"
"\n"
"wall_min_speed = 400\n"
"player_min_speed = 200\n"
"\n"
"wall_max_speed = 100\n"
"player_max_speed = 50\n"
"\n"
"speed_max = 12\n"
"\n"
"\n"
"while True:\n"
"\n"
"    i = m.Image('00000:'*5)\n"
"    s = i.set_pixel\n"
"\n"
"    player_x = 2\n"
"\n"
"    wall_y = -1\n"
"    hole = 0\n"
"\n"
"    score = 0\n"
"    handled_this_wall = False\n"
"\n"
"    wall_speed = wall_min_speed\n"
"    player_speed = player_min_speed\n"
"\n"
"    wall_next = 0\n"
"    player_next = 0\n"
"\n"
"    while True:\n"
"        t = m.running_time()\n"
"        player_update = t >= player_next\n"
"        wall_update = t >= wall_next\n"
"        if not (player_update or wall_update):\n"
"            next_event = min(wall_next, player_next)\n"
"            delta = next_event - t\n"
"            m.sleep(delta)\n"
"            continue\n"
"\n"
"        if wall_update:\n"
"            # calculate new speeds\n"
"            speed = min(score, speed_max)\n"
"            wall_speed = wall_min_speed + int((wall_max_speed - "
"wall_min_speed) * speed / speed_max)\n"
"            player_speed = player_min_speed + int((player_max_speed - "
"player_min_speed) * speed / speed_max)\n"
"\n"
"            wall_next = t + wall_speed\n"
"            if wall_y < 5:\n"
"                # erase old wall\n"
"                use_wall_y = max(wall_y, 0)\n"
"                for wall_x in range(5):\n"
"                    if wall_x != hole:\n"
"                        s(wall_x, use_wall_y, 0)\n"
"\n"
"        wall_reached_player = (wall_y == 4)\n"
"        if player_update:\n"
"            player_next = t + player_speed\n"
"            # find new x coord\n"
"            x = m.accelerometer.get_x()\n"
"            x = min(max(min_x, x), max_x)\n"
"            # print(\"x accel\", x)\n"
"            s(player_x, 4, 0) # turn off old pixel\n"
"            x = ((x - min_x) / range_x) * 5\n"
"            x = min(max(0, x), 4)\n"
"            x = int(x + 0.5)\n"
"            # print(\"have\", position, \"want\", x)\n"
"\n"
"            if not handled_this_wall:\n"
"                if player_x < x:\n"
"                    player_x += 1\n"
"                elif player_x > x:\n"
"                    player_x -= 1\n"
"            # print(\"new\", position)\n"
"            # print()\n"
"\n"
"        if wall_update:\n"
"            # update wall position\n"
"            wall_y += 1\n"
"            if wall_y == 7:\n"
"                wall_y = -1\n"
"                hole = random.randrange(5)\n"
"                handled_this_wall = False\n"
"\n"
"            if wall_y < 5:\n"
"                # draw new wall\n"
"                use_wall_y = max(wall_y, 0)\n"
"                for wall_x in range(5):\n"
"                    if wall_x != hole:\n"
"                        s(wall_x, use_wall_y, 6)\n"
"\n"
"        if wall_reached_player and not handled_this_wall:\n"
"            handled_this_wall = True\n"
"            if (player_x != hole):\n"
"                # collision! game over!\n"
"                break\n"
"            score += 1\n"
"\n"
"        if player_update:\n"
"            s(player_x, 4, 9) # turn on new pixel\n"
"\n"
"        p(i)\n"
"\n"
"    p(i.SAD)\n"
"    m.sleep(1000)\n"
"    m.display.scroll(\"Score:\" + str(score))\n"
"\n"
"    while True:\n"
"        if (m.button_a.is_pressed() and m.button_a.is_pressed()):\n"
"            break\n"
"        m.sleep(100)"
msgstr ""
"# 単純なスラローム　作成者：Larry Hastings　2015年9月。\n"
"#\n"
"# このプログラムはパブリックドメインで公開します。\n"
"\n"
"import microbit as m\n"
"import random\n"
"\n"
"p = m.display.show\n"
"\n"
"min_x = -1024\n"
"max_x = 1024\n"
"range_x = max_x - min_x\n"
"\n"
"wall_min_speed = 400\n"
"player_min_speed = 200\n"
"\n"
"wall_max_speed = 100\n"
"player_max_speed = 50\n"
"\n"
"speed_max = 12\n"
"\n"
"\n"
"while True:\n"
"\n"
"    i = m.Image('00000:'*5)\n"
"    s = i.set_pixel\n"
"\n"
"    player_x = 2\n"
"\n"
"    wall_y = -1\n"
"    hole = 0\n"
"\n"
"    score = 0\n"
"    handled_this_wall = False\n"
"\n"
"    wall_speed = wall_min_speed\n"
"    player_speed = player_min_speed\n"
"\n"
"    wall_next = 0\n"
"    player_next = 0\n"
"\n"
"    while True:\n"
"        t = m.running_time()\n"
"        player_update = t >= player_next\n"
"        wall_update = t >= wall_next\n"
"        if not (player_update or wall_update):\n"
"            next_event = min(wall_next, player_next)\n"
"            delta = next_event - t\n"
"            m.sleep(delta)\n"
"            continue\n"
"\n"
"        if wall_update:\n"
"            # 新しいスピードを計算\n"
"            speed = min(score, speed_max)\n"
"            wall_speed = wall_min_speed + int((wall_max_speed - wall_min_speed) * speed / speed_max)\n"
"            player_speed = player_min_speed + int((player_max_speed - player_min_speed) * speed / speed_max)\n"
"\n"
"            wall_next = t + wall_speed\n"
"            if wall_y < 5:\n"
"                # 古い壁を消す\n"
"                use_wall_y = max(wall_y, 0)\n"
"                for wall_x in range(5):\n"
"                    if wall_x != hole:\n"
"                        s(wall_x, use_wall_y, 0)\n"
"\n"
"        wall_reached_player = (wall_y == 4)\n"
"        if player_update:\n"
"            player_next = t + player_speed\n"
"            # 新しい X 座標を得る\n"
"            x = m.accelerometer.get_x()\n"
"            x = min(max(min_x, x), max_x)\n"
"            # print("x accel", x)\n"
"            s(player_x, 4, 0) # 古いピクセルをオフ\n"
"            x = ((x - min_x) / range_x) * 5\n"
"            x = min(max(0, x), 4)\n"
"            x = int(x + 0.5)\n"
"            # print("have", position, \"want\", x)\n"
"\n"
"            if not handled_this_wall:\n"
"                if player_x < x:\n"
"                    player_x += 1\n"
"                elif player_x > x:\n"
"                    player_x -= 1\n"
"            # print(\"new\", position)\n"
"            # print()\n"
"\n"
"        if wall_update:\n"
"            # 壁の位置を変更\n"
"            wall_y += 1\n"
"            if wall_y == 7:\n"
"                wall_y = -1\n"
"                hole = random.randrange(5)\n"
"                handled_this_wall = False\n"
"\n"
"            if wall_y < 5:\n"
"                # 新しい壁を表示\n"
"                use_wall_y = max(wall_y, 0)\n"
"                for wall_x in range(5):\n"
"                    if wall_x != hole:\n"
"                        s(wall_x, use_wall_y, 6)\n"
"\n"
"        if wall_reached_player and not handled_this_wall:\n"
"            handled_this_wall = True\n"
"            if (player_x != hole):\n"
"                # 衝突！　ゲームオーバー！\n"
"                break\n"
"            score += 1\n"
"\n"
"        if player_update:\n"
"            s(player_x, 4, 9) # 新しいピクセルをオン\n"
"\n"
"        p(i)\n"
"\n"
"    p(i.SAD)\n"
"    m.sleep(1000)\n"
"    m.display.scroll("Score:" + str(score))\n"
"\n"
"    while True:\n"
"        if (m.button_a.is_pressed() and m.button_a.is_pressed()):\n"
"            break\n"
"        m.sleep(100)"

