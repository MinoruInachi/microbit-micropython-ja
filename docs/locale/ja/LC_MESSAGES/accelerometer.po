# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015-2024, Multiple authors
# This file is distributed under the same license as the BBC micro:bit
# MicroPython package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: BBC micro:bit MicroPython 1.1.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-02 11:38+0900\n"
"PO-Revision-Date: 2024-06-02 11:45+0900\n"
"Last-Translator: Minoru Inachi\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../accelerometer.rst:2
msgid "Accelerometer"
msgstr "加速度センサー"

#: ../../accelerometer.rst:6
msgid "This object gives you access to the on-board accelerometer."
msgstr "このオブジェクトでボード上の加速度センサーにアクセスできます。"

#: ../../accelerometer.rst:8
msgid ""
"By default MicroPython sets the accelerometer range to +/- 2000 mg (``g``"
" being a unit of acceleration based on the standard gravity), which "
"configures the maximum and minimum values returned by the accelerometer "
"functions. The range can be changed via "
":func:`microbit.accelerometer.set_range`."
msgstr ""
"MicroPython はデフォルトで加速度センサーの測定範囲を +/- 2000 mg に設定します"
"(``g`` は標準重力に基づく加速度の単位)。"
"この測定範囲から加速度センサーの関数が返す最大値と最小値も決まります。"
":func:`microbit.accelerometer.set_range` を使うと測定範囲を変更できます。"

#: ../../accelerometer.rst:13
msgid ""
"The accelerometer also provides convenience functions for detecting "
"gestures. The recognised gestures are represented as strings: ``up``, "
"``down``, ``left``, ``right``, ``face up``, ``face down``, ``freefall``, "
"``3g``, ``6g``, ``8g``, ``shake``."
msgstr ""
"加速度センサーはジェスチャーをの検出にも使えます。"
"認識できるジェスチャーは文字列で表され、次のものがあります: "
"``up``, ``down``, ``left``, ``right``, ``face up``, ``face down``, "
"``freefall``, ``3g``, ``6g``, ``8g``, ``shake``"

#: ../../accelerometer.rst:20
msgid ""
"Gestures are not updated in the background so there needs to be constant "
"calls to some accelerometer method to do the gesture detection. Usually "
"gestures can be detected using a loop with a small :func:`microbit.sleep`"
" delay."
msgstr ""
"ジェスチャーはバックグラウンドで更新されないので、ジェスチャーの検出を行うには"
"何らかの加速度センサーのメソッドを常に呼び出す必要があります。たいてい、ジェスチャーは "
":func:`microbit.sleep` による短い遅延のあるループを使って検出できます。"

#: ../../accelerometer.rst:26
msgid "Functions"
msgstr "関数"

#: ../../accelerometer.rst
#, fuzzy
msgid "returns"
msgstr "戻り値"

#: ../../accelerometer.rst:30
msgid ""
"The acceleration measurement in the ``x`` axis in milli-g, as a positive "
"or negative integer."
msgstr ""
"``x`` 軸のミリg単位の加速度。値は正または負の整数値です。"

#: ../../accelerometer.rst:35
msgid ""
"The acceleration measurement in the ``y`` axis in milli-g, as a positive "
"or negative integer."
msgstr ""
"``y`` 軸の加速度(ミリg単位)。値は正または負の整数値です。"

#: ../../accelerometer.rst:40
msgid ""
"The acceleration measurement in the ``z`` axis in milli-g, as a positive "
"or negative integer."
msgstr ""
"``z`` 軸の加速度(ミリg単位)。値は正または負の整数値です。"

#: ../../accelerometer.rst:45
msgid ""
"The acceleration measurements in all axes at once, as a three-element "
"tuple of integers ordered as X, Y, Z."
msgstr ""
"すべての軸の加速度。X, Y, Z の並びで整数値のタプルが返ります。"

#: ../../accelerometer.rst:50
msgid ""
"Get the acceleration measurement of all axes combined, as a positive "
"integer.  This is the Pythagorean sum of the X, Y and Z axes."
msgstr ""
"すべての軸を合成した加速度測定値を正の整数値で得ます。"
"これは X軸、Y軸、Z軸のピタゴラス和になります。"

#: ../../accelerometer.rst:53
msgid "The combined acceleration strength of all the axes, in milli-g."
msgstr ""
"すべての軸の合成加速度(ミリg単位)。"

#: ../../accelerometer.rst:57
msgid "String with the name of the current gesture."
msgstr "現在のジェスチャーの名前を表す文字列。"

#: ../../accelerometer.rst
#, fuzzy
msgid "param"
msgstr "パラメータ"

#: ../../accelerometer.rst:61 ../../accelerometer.rst:66
msgid "String with the name of the gesture to check."
msgstr "チェックするジェスチャーの名前を表す文字列。"

#: ../../accelerometer.rst:62
msgid "Boolean indicating if the named gesture is currently active."
msgstr "指定した名前のジェスチャーが認識されているかを示す真偽値。"

#: ../../accelerometer.rst:67
msgid "Boolean indicating if the named gesture was active since the last call."
msgstr "直前の呼出し以降に指定した名前のジェスチャーが認識されたかを示す真偽値。"

#: ../../accelerometer.rst:72
msgid "Get a historical list of the registered gestures."
msgstr "記録されたジェスチャーの履歴リストを得ます。"

#: ../../accelerometer.rst:74
msgid "Calling this function clears the gesture history before returning."
msgstr "この呼出しを行うと、結果を戻す前にジェスチャーの履歴をクリアします。"

#: ../../accelerometer.rst:76
msgid "A tuple of the gesture history, most recent is listed last."
msgstr ""
"ジェスチャー履歴のタプル。タプルは古い順に並び、最新のものが最後の要素になります。"

#: ../../accelerometer.rst:80
msgid ""
"Set the accelerometer sensitivity range, in g (standard gravity), to the "
"closest values supported by the hardware, so it rounds to either ``2``, "
"``4``, or ``8`` g."
msgstr ""
"加速度センサーの感度範囲を g (標準重力)で設定します。"
"設定値は、ハードウェアがサポートする最も近い値、すなわち "
"``2``, ``4``, ``8`` g のいずれかに丸められます。"

#: ../../accelerometer.rst:84
msgid "New range for the accelerometer, an integer in ``g``."
msgstr "加速度センサーの新しい測定範囲。 ``g`` 単位の整数値で指定します。"

#: ../../accelerometer.rst:87
msgid "Examples"
msgstr "サンプルコード"

#: ../../accelerometer.rst:89
msgid ""
"A fortune telling magic 8-ball. Ask a question then shake the device for "
"an answer."
msgstr ""
"マジック８ボール占いです。質問の後にデバイスをゆさぶってください。"

#: ../../accelerometer.rst:92
msgid ""
"# Magic 8 ball by Nicholas Tollervey. February 2016.\n"
"#\n"
"# Ask a question then shake.\n"
"#\n"
"# This program has been placed into the public domain.\n"
"from microbit import *\n"
"import random\n"
"\n"
"answers = [\n"
"    \"It is certain\",\n"
"    \"It is decidedly so\",\n"
"    \"Without a doubt\",\n"
"    \"Yes, definitely\",\n"
"    \"You may rely on it\",\n"
"    \"As I see it, yes\",\n"
"    \"Most likely\",\n"
"    \"Outlook good\",\n"
"    \"Yes\",\n"
"    \"Signs point to yes\",\n"
"    \"Reply hazy try again\",\n"
"    \"Ask again later\",\n"
"    \"Better not tell you now\",\n"
"    \"Cannot predict now\",\n"
"    \"Concentrate and ask again\",\n"
"    \"Don't count on it\",\n"
"    \"My reply is no\",\n"
"    \"My sources say no\",\n"
"    \"Outlook not so good\",\n"
"    \"Very doubtful\",\n"
"]\n"
"\n"
"while True:\n"
"    display.show('8')\n"
"    if accelerometer.was_gesture('shake'):\n"
"        display.clear()\n"
"        sleep(1000)\n"
"        display.scroll(random.choice(answers))\n"
"    sleep(10)"
msgstr ""
"# マジック８ボール占い　作成者：Nicholas Tollervey　2016年2月。\n"
"#\n"
"# 質問の後にデバイスを振ってゆさぶってください。\n"
"#\n"
"# このプログラムはパブリックドメインで公開します。\n"
"from microbit import *\n"
"import random\n"
"\n"
"answers = [\n"
"    \"It is certain\",\n"
"    \"It is decidedly so\",\n"
"    \"Without a doubt\",\n"
"    \"Yes, definitely\",\n"
"    \"You may rely on it\",\n"
"    \"As I see it, yes\",\n"
"    \"Most likely\",\n"
"    \"Outlook good\",\n"
"    \"Yes\",\n"
"    \"Signs point to yes\",\n"
"    \"Reply hazy try again\",\n"
"    \"Ask again later\",\n"
"    \"Better not tell you now\",\n"
"    \"Cannot predict now\",\n"
"    \"Concentrate and ask again\",\n"
"    \"Don't count on it\",\n"
"    \"My reply is no\",\n"
"    \"My sources say no\",\n"
"    \"Outlook not so good\",\n"
"    \"Very doubtful\",\n"
"]\n"
"\n"
"while True:\n"
"    display.show('8')\n"
"    if accelerometer.was_gesture('shake'):\n"
"        display.clear()\n"
"        sleep(1000)\n"
"        display.scroll(random.choice(answers))\n"
"    sleep(10)"

#: ../../accelerometer.rst:99
msgid "Simple Slalom. Move the device to avoid the obstacles."
msgstr "単純なスラロームです。デバイスを動かして障害物を避けてください。"

msgid ""
"# Simple Slalom by Larry Hastings, September 2015\n"
"#\n"
"# This program has been placed into the public domain.\n"
"\n"
"import microbit as m\n"
"import random\n"
"\n"
"p = m.display.show\n"
"\n"
"min_x = -1024\n"
"max_x = 1024\n"
"range_x = max_x - min_x\n"
"\n"
"wall_min_speed = 400\n"
"player_min_speed = 200\n"
"\n"
"wall_max_speed = 100\n"
"player_max_speed = 50\n"
"\n"
"speed_max = 12\n"
"\n"
"\n"
"while True:\n"
"\n"
"    i = m.Image('00000:'*5)\n"
"    s = i.set_pixel\n"
"\n"
"    player_x = 2\n"
"\n"
"    wall_y = -1\n"
"    hole = 0\n"
"\n"
"    score = 0\n"
"    handled_this_wall = False\n"
"\n"
"    wall_speed = wall_min_speed\n"
"    player_speed = player_min_speed\n"
"\n"
"    wall_next = 0\n"
"    player_next = 0\n"
"\n"
"    while True:\n"
"        t = m.running_time()\n"
"        player_update = t >= player_next\n"
"        wall_update = t >= wall_next\n"
"        if not (player_update or wall_update):\n"
"            next_event = min(wall_next, player_next)\n"
"            delta = next_event - t\n"
"            m.sleep(delta)\n"
"            continue\n"
"\n"
"        if wall_update:\n"
"            # calculate new speeds\n"
"            speed = min(score, speed_max)\n"
"            wall_speed = wall_min_speed + int((wall_max_speed - "
"wall_min_speed) * speed / speed_max)\n"
"            player_speed = player_min_speed + int((player_max_speed - "
"player_min_speed) * speed / speed_max)\n"
"\n"
"            wall_next = t + wall_speed\n"
"            if wall_y < 5:\n"
"                # erase old wall\n"
"                use_wall_y = max(wall_y, 0)\n"
"                for wall_x in range(5):\n"
"                    if wall_x != hole:\n"
"                        s(wall_x, use_wall_y, 0)\n"
"\n"
"        wall_reached_player = (wall_y == 4)\n"
"        if player_update:\n"
"            player_next = t + player_speed\n"
"            # find new x coord\n"
"            x = m.accelerometer.get_x()\n"
"            x = min(max(min_x, x), max_x)\n"
"            # print(\"x accel\", x)\n"
"            s(player_x, 4, 0) # turn off old pixel\n"
"            x = ((x - min_x) / range_x) * 5\n"
"            x = min(max(0, x), 4)\n"
"            x = int(x + 0.5)\n"
"            # print(\"have\", position, \"want\", x)\n"
"\n"
"            if not handled_this_wall:\n"
"                if player_x < x:\n"
"                    player_x += 1\n"
"                elif player_x > x:\n"
"                    player_x -= 1\n"
"            # print(\"new\", position)\n"
"            # print()\n"
"\n"
"        if wall_update:\n"
"            # update wall position\n"
"            wall_y += 1\n"
"            if wall_y == 7:\n"
"                wall_y = -1\n"
"                hole = random.randrange(5)\n"
"                handled_this_wall = False\n"
"\n"
"            if wall_y < 5:\n"
"                # draw new wall\n"
"                use_wall_y = max(wall_y, 0)\n"
"                for wall_x in range(5):\n"
"                    if wall_x != hole:\n"
"                        s(wall_x, use_wall_y, 6)\n"
"\n"
"        if wall_reached_player and not handled_this_wall:\n"
"            handled_this_wall = True\n"
"            if (player_x != hole):\n"
"                # collision! game over!\n"
"                break\n"
"            score += 1\n"
"\n"
"        if player_update:\n"
"            s(player_x, 4, 9) # turn on new pixel\n"
"\n"
"        p(i)\n"
"\n"
"    p(i.SAD)\n"
"    m.sleep(1000)\n"
"    m.display.scroll(\"Score:\" + str(score))\n"
"\n"
"    while True:\n"
"        if (m.button_a.is_pressed() and m.button_a.is_pressed()):\n"
"            break\n"
"        m.sleep(100)"
msgstr ""
"# 単純なスラローム　作成者：Larry Hastings　2015年9月。\n"
"#\n"
"# このプログラムはパブリックドメインで公開します。\n"
"\n"
"import microbit as m\n"
"import random\n"
"\n"
"p = m.display.show\n"
"\n"
"min_x = -1024\n"
"max_x = 1024\n"
"range_x = max_x - min_x\n"
"\n"
"wall_min_speed = 400\n"
"player_min_speed = 200\n"
"\n"
"wall_max_speed = 100\n"
"player_max_speed = 50\n"
"\n"
"speed_max = 12\n"
"\n"
"\n"
"while True:\n"
"\n"
"    i = m.Image('00000:'*5)\n"
"    s = i.set_pixel\n"
"\n"
"    player_x = 2\n"
"\n"
"    wall_y = -1\n"
"    hole = 0\n"
"\n"
"    score = 0\n"
"    handled_this_wall = False\n"
"\n"
"    wall_speed = wall_min_speed\n"
"    player_speed = player_min_speed\n"
"\n"
"    wall_next = 0\n"
"    player_next = 0\n"
"\n"
"    while True:\n"
"        t = m.running_time()\n"
"        player_update = t >= player_next\n"
"        wall_update = t >= wall_next\n"
"        if not (player_update or wall_update):\n"
"            next_event = min(wall_next, player_next)\n"
"            delta = next_event - t\n"
"            m.sleep(delta)\n"
"            continue\n"
"\n"
"        if wall_update:\n"
"            # 新しいスピードを計算\n"
"            speed = min(score, speed_max)\n"
"            wall_speed = wall_min_speed + int((wall_max_speed - wall_min_speed) * speed / speed_max)\n"
"            player_speed = player_min_speed + int((player_max_speed - player_min_speed) * speed / speed_max)\n"
"\n"
"            wall_next = t + wall_speed\n"
"            if wall_y < 5:\n"
"                # 古い壁を消す\n"
"                use_wall_y = max(wall_y, 0)\n"
"                for wall_x in range(5):\n"
"                    if wall_x != hole:\n"
"                        s(wall_x, use_wall_y, 0)\n"
"\n"
"        wall_reached_player = (wall_y == 4)\n"
"        if player_update:\n"
"            player_next = t + player_speed\n"
"            # 新しい X 座標を得る\n"
"            x = m.accelerometer.get_x()\n"
"            x = min(max(min_x, x), max_x)\n"
"            # print("x accel", x)\n"
"            s(player_x, 4, 0) # 古いピクセルをオフ\n"
"            x = ((x - min_x) / range_x) * 5\n"
"            x = min(max(0, x), 4)\n"
"            x = int(x + 0.5)\n"
"            # print("have", position, \"want\", x)\n"
"\n"
"            if not handled_this_wall:\n"
"                if player_x < x:\n"
"                    player_x += 1\n"
"                elif player_x > x:\n"
"                    player_x -= 1\n"
"            # print(\"new\", position)\n"
"            # print()\n"
"\n"
"        if wall_update:\n"
"            # 壁の位置を変更\n"
"            wall_y += 1\n"
"            if wall_y == 7:\n"
"                wall_y = -1\n"
"                hole = random.randrange(5)\n"
"                handled_this_wall = False\n"
"\n"
"            if wall_y < 5:\n"
"                # 新しい壁を表示\n"
"                use_wall_y = max(wall_y, 0)\n"
"                for wall_x in range(5):\n"
"                    if wall_x != hole:\n"
"                        s(wall_x, use_wall_y, 6)\n"
"\n"
"        if wall_reached_player and not handled_this_wall:\n"
"            handled_this_wall = True\n"
"            if (player_x != hole):\n"
"                # 衝突！　ゲームオーバー！\n"
"                break\n"
"            score += 1\n"
"\n"
"        if player_update:\n"
"            s(player_x, 4, 9) # 新しいピクセルをオン\n"
"\n"
"        p(i)\n"
"\n"
"    p(i.SAD)\n"
"    m.sleep(1000)\n"
"    m.display.scroll("Score:" + str(score))\n"
"\n"
"    while True:\n"
"        if (m.button_a.is_pressed() and m.button_a.is_pressed()):\n"
"            break\n"
"        m.sleep(100)"

